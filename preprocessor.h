#include <iostream>
#include <fstream>
#include <regex>
#include <string>
#include <vector>
#include <filesystem>
#include <sstream>

// Функция для проверки, является ли класс абстрактным
bool isAbstractClass(const std::string& content, std::string& className) {
    std::regex classRegex(R"(class\s+(\w+)\s*\{\s*public\s*:\s*virtual)");
    std::smatch match;
    if (std::regex_search(content, match, classRegex)) {
        className = match[1];
        return true;
    }
    return false;
}

// Генерация методов адаптера с использованием IoC для разрешения зависимостей
void generateAdapterMethods(const std::vector<std::string>& methods, std::ofstream& outputFile, const std::string& className, const std::string& targetClassName) {
    for (const auto& method : methods) {
        std::regex methodRegex(R"((\w+)\s+(\w+)\s*\(([^)]*)\))");
        std::smatch match;
        if (std::regex_match(method, match, methodRegex)) {
            std::string returnType = match[1];
            std::string methodName = match[2];
            std::string args = match[3];

            // Обработка для метода setPosition
            if (methodName == "setPosition" && returnType == "void") {
                outputFile << "\tMovable& " << methodName << "(const Vector& vector) override {\n";
                outputFile << "\t\tioc->Resolve<void>(key + \"::" << methodName << "\", {object, const_cast<Vector*>(&vector)});\n";
                outputFile << "\t\treturn *this;\n";
                outputFile << "\t}\n";
            } else {
                // Генерация других методов
                outputFile << "\t" << returnType << " " << methodName << "() const override {\n";
                outputFile << "\t\treturn *ioc->Resolve<" << returnType << ">(key + \"::" << methodName << "\", {object});\n";
                outputFile << "\t}\n";
            }
        }
    }
}

// Генерация адаптера для абстрактного класса
void generateAdapter(const std::string& className, const std::vector<std::string>& methods, std::ofstream& outputFile, const std::string& targetClassName) {
    outputFile << "#pragma once\n";
    outputFile << "#include \"" << className << ".h\"\n";
    outputFile << "#include \"ioc.h\"\n";
    outputFile << "#include <string>\n";
    outputFile << "#include \"" << targetClassName << ".h\"\n\n";

    outputFile << "class AutoGenerated_" << className << "Adapter : public " << className << " {\n";
    outputFile << "public:\n";
    outputFile << "\tAutoGenerated_" << className << "Adapter(IoC* ioc, const std::string& key, " << targetClassName << "* object)\n";
    outputFile << "\t\t: ioc(ioc), key(key), object(object) {}\n\n";

    // Генерация методов адаптера
    generateAdapterMethods(methods, outputFile, className, targetClassName);

    outputFile << "private:\n";
    outputFile << "\tIoC* ioc;\n";
    outputFile << "\tstd::string key;\n";
    outputFile << "\t" << targetClassName << "* object; // Указатель на объект целевого класса\n";
    outputFile << "};\n\n";
}

// Препроцессор для поиска абстрактных классов и генерации адаптеров
void preprocess(const std::string& headerFilePath, const std::string& outputFilePath, const std::string& targetClassName) {
    std::ifstream headerFile(headerFilePath);
    std::ofstream outputFile(outputFilePath, std::ios::app); // Открытие файла для добавления

    if (!headerFile.is_open()) {
        std::cerr << "Ошибка при открытии файла: " << headerFilePath << std::endl;
        return;
    }

    if (!outputFile.is_open()) {
        std::cerr << "Ошибка при открытии файла на запись: " << outputFilePath << std::endl;
        return;
    }

    std::string content((std::istreambuf_iterator<char>(headerFile)), std::istreambuf_iterator<char>());
    std::string className;

    std::vector<std::string> methods = {
        "Vector getPosition()",
        "void setPosition(Vector newValue)",
        "Vector getVelocity()",
    };

    if (isAbstractClass(content, className)) {
        std::cout << "Найден абстрактный класс: " << className << "\n";
        generateAdapter(className, methods, outputFile, targetClassName);
    }

    headerFile.close();
    outputFile.close();
}
