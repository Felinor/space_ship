#include <iostream>
#include <stdexcept>
#include <functional>
#include <filesystem>
#include "spaceship.h"
#include "movement.h"
#include "exception_queue.h"
#include "checkFuelCommand.h"
#include "burnFuelCommand.h"
#include "macroCommand.h"
#include "rotateAndChangeVelocity.h"
#include "moveWithFuel.h"
#include "changeVelocity.h"
#include "ioc.h"
#include "preprocessor.h"
#include "vector.h"
#include "AutoGenerated_MovableAdapter.h"
#include "safequeue.h"

// Проверяем результат теста
void assertEquals(const Vector& a, const Vector& b, const std::string& testName) {
    if (!(a == b)) {
        std::cerr << "Test " << testName << " failed: expected " << a << ", got " << b << std::endl;
    } else {
        std::cout << "Test " << testName << " passed." << std::endl;
    }
}

void assertThrows(std::function<void()> func, const std::string& testName) {
    try {
        func();
        std::cerr << "Test " << testName << " failed: expected an exception." << std::endl;
    } catch (const std::exception& e) {
        std::cout << "Test " << testName << " passed: caught exception \"" << e.what() << "\"." << std::endl;
    } catch (...) {
        std::cerr << "Test " << testName << " failed: caught unknown exception." << std::endl;
    }
}

// Тест на корректное перемещение объекта
void testMoveChangesPositionCorrectly() {
    SpaceShip ship(Vector(12, 5), 0.0);
    ship.setVelocity(Vector(-7, 3));

    Movement::Move(ship);

    assertEquals(ship.getPosition(), Vector(5, 8), "MoveChangesPositionCorrectly");
}

// Объект с ошибкой при попытке прочитать положение
class FaultyPositionShip : public Movable {
public:
    Vector getPosition() const override {
        throw std::runtime_error("Cannot read position");
    }
    Vector getVelocity() const override {
        return Vector(0, 0);
    }
    Movable& setPosition(const Vector&) override {
        return *this;
    }
};

// Ошибка чтения позиции
void testMoveThrowsOnPositionReadError() {
    FaultyPositionShip ship;
    assertThrows([&]() { Movement::Move(ship); }, "MoveThrowsOnPositionReadError");
}

// Объект с ошибкой при попытке прочитать скорость
class FaultyVelocityShip : public Movable {
public:
    Vector getPosition() const override {
        return Vector(0, 0);
    }
    Vector getVelocity() const override {
        throw std::runtime_error("Cannot read velocity");
    }
    Movable& setPosition(const Vector&) override {
        return *this;
    }
};

// Ошибка чтения скорости
void testMoveThrowsOnVelocityReadError() {
    FaultyVelocityShip ship;
    assertThrows([&]() { Movement::Move(ship); }, "MoveThrowsOnVelocityReadError");
}

// Объект с ошибкой при попытке изменить положение
class FaultySetPositionShip : public Movable {
public:
    Vector getPosition() const override {
        return Vector(0, 0);
    }
    Vector getVelocity() const override {
        return Vector(1, 1);
    }
    Movable& setPosition(const Vector&) override {
        throw std::runtime_error("Cannot set position");
    }
};

// Ошибка установки нового положения
void testMoveThrowsOnSetPositionError() {
    FaultySetPositionShip ship;
    assertThrows([&]() { Movement::Move(ship); }, "MoveThrowsOnSetPositionError");
}

// Тесты
void testLogCommandLogsException() {
    CommandQueue queue;
    std::cout << "\nTest 4: LogCommand logs exception\n";
    try {
        auto failingCommand = std::make_shared<FailingCommand>();
        throw std::runtime_error("Test exception");
    } catch (const std::exception& ex) {
        auto cmd = std::make_shared<FailingCommand>();
        auto logCmd = std::make_shared<LogCommand>(cmd, ex);
        queue.AddCommand(logCmd);
    }
    queue.ProcessCommands();  // Ожидаем вывод логирования исключения
}

void testHandleExceptionAddsLogCommandToQueue() {
    CommandQueue queue;
    std::cout << "\nTest 5: HandleException adds LogCommand to queue\n";
    auto failingCommand5 = std::make_shared<FailingCommand>();
    try {
        failingCommand5->Execute();
    } catch (const std::exception& ex) {
        queue.HandleException(failingCommand5, ex);
    }
    queue.ProcessCommands();  // Ожидаем добавления LogCommand
}

void testRetryCommandRetriesExecution() {
    CommandQueue queue;
    std::cout << "\nTest 6: RetryCommand retries execution\n";
    auto retryCmd = std::make_shared<RetryCommand>(std::make_shared<FailingCommand>(), 2);
    queue.AddCommand(retryCmd);
    queue.ProcessCommands();  // Ожидаем повтор выполнения команды
}

void testHandleExceptionAddsRetryCommandToQueue() {
    CommandQueue queue;
    std::cout << "\nTest 7: HandleException adds RetryCommand to queue\n";
    auto failingCommand7 = std::make_shared<FailingCommand>();
    try {
        failingCommand7->Execute();
    } catch (const std::exception& ex) {
        queue.HandleException(failingCommand7, ex);
    }
    queue.ProcessCommands();  // Ожидаем добавления RetryCommand
}

void testRetryThenLogOnException() {
    CommandQueue queue;
    std::cout << "\nTest 8: Retry then Log on exception\n";
    auto failingCommand8 = std::make_shared<FailingCommand>();
    queue.AddCommand(failingCommand8);
    queue.ProcessCommands();  // Ожидаем повтор и логирование после второго исключения
}

void testRetryTwiceThenLogOnException() {
    CommandQueue queue;
    std::cout << "\nTest 9: Retry twice, then log on exception\n";
    auto retryTwiceCmd = std::make_shared<RetryTwiceCommand>(std::make_shared<FailingCommand>());
    queue.AddCommand(retryTwiceCmd);
    queue.ProcessCommands();  // Ожидаем два повтора и логирование ошибки после третьего исключения
}

// Тест проверяет достаточно ли топлива для выполнения действия
void testCheckFuelCommandPasses() {
    SpaceShip ship(Vector(0, 0), 0);
    ship.setFuel(100);
    CheckFuelCommand checkFuelCmd(ship, 50);
    checkFuelCmd.Execute();  // Должно пройти без исключений
    std::cout << "Test CheckFuelCommandPasses passed." << std::endl;
}

// Если топлива недостаточно - получаем исключение
void testCheckFuelCommandFails() {
    SpaceShip ship(Vector(0, 0), 0);
    ship.setFuel(30);
    CheckFuelCommand checkFuelCmd(ship, 50);
    assertThrows([&]() { checkFuelCmd.Execute(); }, "CheckFuelCommandFails");
}

// Тест уменьшения количества топлива при выполнении команды
void testBurnFuelCommand() {
    SpaceShip ship(Vector(0, 0), 0);
    ship.setFuel(100);
    BurnFuelCommand burnFuelCmd(ship, 20);
    burnFuelCmd.Execute();  // Сжигаем 20 единиц топлива
    assertEquals(ship.getFuel(), 80, "BurnFuelCommand");
}

// Тест будет выполнять несколько команд последовательно, останавливая выполнение при выбросе исключения
void testMoveWithFuelConsumption() {
    SpaceShip ship(Vector(0, 0), 0.0);
    ship.setFuel(10);  // Устанавливаем топливо

    double fuelConsumptionRate = 5; // Скорость расхода топлива

    // Создаем цепочку команд
    std::vector<std::shared_ptr<Command>> commands = {
        std::make_shared<CheckFuelCommand>(ship, fuelConsumptionRate),
        std::make_shared<MoveWithFuelCommand>(ship, fuelConsumptionRate),
        std::make_shared<BurnFuelCommand>(ship, fuelConsumptionRate)
    };

    MacroCommand moveWithFuel(commands);
    moveWithFuel.Execute();  // Выполняем макрокоманду
}

// Тест изменения вектора скорости
void testChangeVelocityCommand() {
    SpaceShip ship(Vector(0, 0), 0);
    Vector newVelocity(10, 5);
    ChangeVelocityCommand changeVelocity(ship, newVelocity);

    changeVelocity.Execute();
    if (ship.getVelocity() == newVelocity) {
        std::cout << "Test ChangeVelocityCommand passed.\n";
    } else {
        std::cerr << "Test ChangeVelocityCommand failed.\n";
    }
}

// Тест команды поворота, которая еще и меняет вектор мгновенной скорости
void testRotateAndChangeVelocity() {
    SpaceShip ship(Vector(0, 0), 0);
    ship.setFuel(10);

    double fuelConsumptionRate = 5;

    // Создаем цепочку команд
    std::vector<std::shared_ptr<Command>> commands = {
        std::make_shared<CheckFuelCommand>(ship, fuelConsumptionRate),
        std::make_shared<MoveWithFuelCommand>(ship, fuelConsumptionRate),
        std::make_shared<ChangeVelocityCommand>(ship, Vector(10, 10)),
        std::make_shared<RotateAndChangeVelocity>(ship, 90, Vector(5, 5)),
        std::make_shared<BurnFuelCommand>(ship, fuelConsumptionRate)
    };

    MacroCommand rotateAndChangeVelocity(commands);
    rotateAndChangeVelocity.Execute();

    // Проверяем, что корабль повернулся на 90 градусов
    assertEquals(ship.getRotation(), 90.0, "RotateAndChangeVelocity: Rotation");

    // Проверяем, что скорость изменена
    assertEquals(ship.getVelocity(), Vector(-10, 10), "RotateAndChangeVelocity: Velocity");
}

// Тест команды поворота, которая не меняет вектор мгновенной скорости
void testRotateAndWithoutChangeVelocity() {
    SpaceShip ship(Vector(0, 0), 0);

    Vector velocity(0, 0);

    // Создаем цепочку команд
    std::vector<std::shared_ptr<Command>> noMovementCommands = {
        std::make_shared<ChangeVelocityCommand>(ship, velocity),
        std::make_shared<RotateAndChangeVelocity>(ship, 45, velocity),
    };

    MacroCommand noMovementRotate(noMovementCommands);
    noMovementRotate.Execute();

    // Проверяем, что корабль повернулся на 45 градусов
    assertEquals(ship.getRotation(), 45.0, "RotateWithoutChangeVelocity: Rotation with no movement");
    // Проверяем, что скорость осталась нулевой
    assertEquals(ship.getVelocity(), velocity, "RotateWithoutChangeVelocity: Velocity with no movement");
}

// Многопоточный тест
void testIoCInMultithreadedEnvironment() {
    // Фейковый класс команды для движения
    class MoveCommand {
    public:
        void Execute() {
            std::cout << "Moving forward! ";
        }
    };

    IoC container;

    // Потоковая функция для работы со скоупами
    auto threadFunction = [&container](const std::string& scopeName, const std::string& commandName) {
        try {
            // Создаем новый скоуп для потока
            container.CreateScope(scopeName);

            // Регистрируем команду в скоупе
            container.Register<MoveCommand>(commandName, [](std::vector<void*>) { return new MoveCommand(); });

            // Разрешаем и выполняем команду
            auto moveCommand = container.Resolve<MoveCommand>(commandName);
            moveCommand->Execute();

            std::cout << commandName << std::endl;

            // Проверяем, что команда была успешно разрешена и выполнена
            assert(moveCommand != nullptr);
        } catch (const std::exception& e) {
            std::cerr << "Error in thread: " << e.what() << std::endl;
        }
    };

    // Создаем потоки, каждый со своим скоупом и командой
    std::thread thread1(threadFunction, "scope1", "MoveCommand1");
    std::thread thread2(threadFunction, "scope2", "MoveCommand2");

    // Ждем завершения потоков
    thread1.join();
    thread2.join();

    // Убедимся, что команды были изолированы
    try {
        // Попробуем разрешить команду из scope1 в текущем потоке (что должно привести к исключению)
        container.Resolve<MoveCommand>("MoveCommand1");
        assert(false); // Эта строка не должна выполниться, т.к. команда из другого скоупа
    } catch (const std::runtime_error& e) {
        std::cout << "Successfully isolated scope: " << e.what() << std::endl;
    }
}

// Тест адаптера
void testAdapter() {
    IoC ioc;

    // Регистрация зависимостей для SpaceShip
    ioc.Register<Vector>("SpaceShip::getPosition", [](std::vector<void*> args) -> Vector* {
        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
        return new Vector(spaceship->getPosition()); // Возвращаем текущую позицию
    });

    ioc.Register<void>("SpaceShip::setPosition", [](std::vector<void*> args) -> void* {
        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
        Vector* newPosition = static_cast<Vector*>(args[1]);
        spaceship->setPosition(*newPosition);
        return nullptr; // Возвращаем void
    });

    ioc.Register<Vector>("SpaceShip::getVelocity", [](std::vector<void*> args) -> Vector* {
        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
        return new Vector(spaceship->getVelocity()); // Возвращаем текущую скорость
    });

    // Создание объекта SpaceShip
    SpaceShip spaceship(Vector(0, 0), Rotation(0));
    spaceship.setVelocity(Vector(15, 25));

    // Создание адаптера
    AutoGenerated_MovableAdapter adapter(&ioc, "SpaceShip", &spaceship);

    // Проверка установки позиции через адаптер
    adapter.setPosition(Vector(10, 20));
    Vector position = adapter.getPosition();
    assert(position.X == 10 && position.Y == 20);

    Vector velocity = adapter.getVelocity();
    assert(velocity.X == 15 && velocity.Y == 25);

    std::cout << "testAdapter passed.\n";
}

// Thread pool tests
void hardStopTest() {
    SafeQueue queue;

    // Добавление задач
    queue.addTask([]() {
        std::cout << "Task 1 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 1 completed\n";
    });

    // Команда не должна выполниться так как вызываем hardStop() после первой команды
    queue.addTask([]() {
        std::cout << "Task 2 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 2 completed\n";
        std::cout << "Test failed!\n";
    });

    // Запуск обработки задач
    queue.start();

    // Ждем некоторое время и вызываем hardStop()
    std::this_thread::sleep_for(std::chrono::seconds(1));
    queue.hardStop();
}

void softStopTest() {
    SafeQueue queue;

    // Добавление задач
    queue.addTask([]() {
        std::cout << "Task 1 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 1 completed\n";
    });

    // Команда должна выполниться так как вызываем softStop() после выполнения первой команды
    queue.addTask([]() {
        std::cout << "Task 2 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 2 completed\n";
    });

    // Запуск обработки задач
    queue.start();

    // Ждем некоторое время и вызываем softStop()
    std::this_thread::sleep_for(std::chrono::seconds(1));
    queue.softStop();
}

void exceptionTest() {
    SafeQueue queue;

    // Добавление задач
    queue.addTask([]() {
        std::cout << "Task 1 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 1 completed\n";
    });

    // Задача которая вызывает exception
    queue.addTask([]() {
        std::cout << "Task 2 running in thread ID: " << std::this_thread::get_id() << "\n";
        throw std::runtime_error("Task 2 encountered an error!");
    });

    // Команда должна выполниться после exception в предыдущей команде
    queue.addTask([]() {
        std::cout << "Task 3 running in thread ID: " << std::this_thread::get_id() << "\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 3 completed\n";
    });

    // Запуск обработки задач
    queue.start();

    // Ожидаем выполнение работы
    std::this_thread::sleep_for(std::chrono::seconds(2));
}

void startTest() {
    SafeQueue queue;
    SpaceShip ship(Vector(12, 5), 0.0);

    // Добавление задач
    queue.addTask([&ship]() {
        std::cout << "Task 1 running in thread ID: " << std::this_thread::get_id() << "\n";
        ship.setVelocity(Vector(-7, 3));
        Movement::Move(ship);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 1 completed. New ship position: " << ship.getPosition() << "\n";
    });

    queue.addTask([&ship]() {
        std::cout << "Task 2 running in thread ID: " << std::this_thread::get_id() << "\n";
        ship.setVelocity(Vector(-7, 3));
        Movement::Move(ship);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 2 completed. New ship position: " << ship.getPosition() << "\n";
    });

    // Запуск обработки задач
    queue.start();

    // Ожидаем выполнение работы
    std::this_thread::sleep_for(std::chrono::seconds(4));

    std::cout << "Additional task added.\n";
    // Добавляем новую задачу в поток и пробуждаем его
    queue.addTask([&ship]() {
        std::cout << "Task 3 running in thread ID: " << std::this_thread::get_id() << "\n";
        ship.setVelocity(Vector(-7, 3));
        Movement::Move(ship);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Task 3 completed. New ship position: " << ship.getPosition() << "\n";
    });

    // Ожидаем выполнение работы
    std::this_thread::sleep_for(std::chrono::seconds(2));
}

int main(int argc, char **argv) {
// Thread pool
// -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
    std::cout << "Main programm thread ID: " << std::this_thread::get_id() << "\n";
    startTest();
//    hardStopTest();
//    softStopTest();
//    exceptionTest();

// Адаптер и кодогенерация
// -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
//    std::filesystem::path programPath(argv[0]);

//    // Извлекаем путь до каталога сборки
//    std::filesystem::path buildDir = programPath.parent_path();

//    // Путь до корневого каталога проекта
//    std::filesystem::path projectRootDir = buildDir.parent_path();

//    // Путь до файла movable.h в каталоге с исходниками
//    std::filesystem::path movablePath = projectRootDir / "space_ship" / "movable.h";

//    std::cout << "Путь до movable.h: " << movablePath << std::endl;

//    // Читаем файл movable.h и генерируем адаптер
//    preprocess(movablePath, "autoGenerated_movableAdapter.h", "SpaceShip");

//    std::cout << "Препроцессинг завершен!\n";

//    IoC ioc;

//    // Регистрация зависимостей для SpaceShip
//    ioc.Register<Vector>("SpaceShip::getPosition", [](std::vector<void*> args) -> Vector* {
//        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
//        return new Vector(spaceship->getPosition()); // Возвращаем текущую позицию
//    });

//    ioc.Register<void>("SpaceShip::setPosition", [](std::vector<void*> args) -> void* {
//        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
//        Vector* newPosition = static_cast<Vector*>(args[1]);
//        spaceship->setPosition(*newPosition);
//        return nullptr; // Возвращаем void
//    });

//    ioc.Register<Vector>("SpaceShip::getVelocity", [](std::vector<void*> args) -> Vector* {
//        SpaceShip* spaceship = static_cast<SpaceShip*>(args[0]);
//        return new Vector(spaceship->getVelocity()); // Возвращаем текущую скорость
//    });

//    // Создание объекта SpaceShip
//    SpaceShip spaceship(Vector(0, 0), Rotation(0));

//    // Создание адаптера для SpaceShip через IoC
//    AutoGenerated_MovableAdapter adapter(&ioc, "SpaceShip", &spaceship);

//    // Используем адаптер
//    Vector position = adapter.getPosition();
//    std::cout << "Old Position: (" << position.X << ", " << position.Y << ")\n";
//    adapter.setPosition(Vector(10, 20));
//    position = adapter.getPosition();
//    std::cout << "New Position: (" << position.X << ", " << position.Y << ")\n";

//    // Запуск тестов
//    testAdapter();
// -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

//    testIoCInMultithreadedEnvironment();

//    testCheckFuelCommandPasses();
//    testCheckFuelCommandFails();
//    testBurnFuelCommand();
//    testMoveWithFuelConsumption();
//    testChangeVelocityCommand();
//    testRotateAndChangeVelocity();
//    testRotateAndWithoutChangeVelocity();

//    testMoveChangesPositionCorrectly();
//    testMoveThrowsOnPositionReadError();
//    testMoveThrowsOnVelocityReadError();
//    testMoveThrowsOnSetPositionError();

//    testLogCommandLogsException();           // Test 4
//    testHandleExceptionAddsLogCommandToQueue(); // Test 5
//    testRetryCommandRetriesExecution();      // Test 6
//    testHandleExceptionAddsRetryCommandToQueue(); // Test 7
//    testRetryThenLogOnException();           // Test 8
//    testRetryTwiceThenLogOnException();      // Test 9

    return 0;
}
